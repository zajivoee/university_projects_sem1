# Date

Перед вами исходный код операционной системы xv6.
Вам нужно добавить в xv6 новый системный вызов.

Системный вызов имеет сигнатуру:

```c
int date(struct rtcdate* date);
```

Он должен читать значение часов с CMOS таймера и заполнять структуру по адресу в первом аргументе.
Структура `struct rtcdate` определена в файле `date.h`.
В случае успеха нужно вернуть `0`. В случае ошибки системный вызов должен вернуть `-1`.

Для работы с аппаратурой в ядре уже есть функция `cmostime()`. Эта фунция заполняет поля структуры датой по UTC.

Помните, что ядро не может доверять пользовательским указателям, и перед работай с ними нужно убедиться что указатели ссылаются на память внутри пользовательского процесса. Посмотрите как это делается в системном вызове read (в xv6 процессу отдаётся память от 0 до `curproc->sz`).

Вам можно менять файлы:
  * date.c - userspace программа, нужна вам чтобы тестировать свой код
  * usys.S - wrapper-ы для системных вызовов
  * user.h - заголовочный файл с объявлениями функций из usys.S
  * syscall.h, syscall.c, sysproc.c - нужные вам части ядра

Тесты в задаче проверяют, что ваша программа `date` выводит текущее время пояса UTC0 в формате `%Y-%m-%dT%H:%M:%S`.
Если происходит ошибка, то программа `date` ничего не должна выводить.

## Тестирование

* Запускать xv6 можно в докере

* Запуск xv6
  ```console
  make qemu-nox
  ```

* Для выхода из qemu используйте `ctrl+a x`

* Запуск под gdb
  * Запустить xv6
    ```console
    make qemu-nox-gdb
    ```
      Исполнение должно зависнуть, позже в этом терминале вы сможете взаимодействовать с xv6

  * Далее нужно в новом терминале подключиться к запущенному контейнеру
    ```console
    docker container list
    docker exec -it <container_id> bash
    ```

  * Запускаем gdb
    ```console
    make gdb
    ```
